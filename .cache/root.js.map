{"version":3,"sources":["../../src/cache-dir/root.js"],"names":["addPagesArray","addDevRequires","window","___loader","history","attachToHistory","___history","listen","location","action","shouldUpdateScroll","prevRouterProps","pathname","results","length","oldPathname","noMatch","find","r","path","addNotFoundRoute","key","component","components","componentChunkName","props","json","jsonName","navigateTo","push","___navigateTo","AltRouter","DefaultRouter","children","layout","layouts","Root","render","routeProps","layoutProps","pageResources","getResourcesForPathname","WrappedRoot"],"mappings":";;;;;;;;;;AAAA;;;;AACA;;AAMA;;AACA;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AACA,iBAAOA,aAAP;AACA,iBAAOC,cAAP;AACAC,OAAOC,SAAP;;AAEA,IAAMC,UAAU,qCAAhB;;AAEA,SAASC,eAAT,CAAyBD,OAAzB,EAAkC;AAChCF,SAAOI,UAAP,GAAoBF,OAApB;;AAEAA,UAAQG,MAAR,CAAe,UAACC,QAAD,EAAWC,MAAX,EAAsB;AACnC,oCAAW,eAAX,EAA2B,EAAED,QAAF,EAAYC,MAAZ,EAA3B;AACD,GAFD;AAGD;;AAED,SAASC,kBAAT,CAA4BC,eAA5B,QAAyE;AAAA,MAAdC,QAAc,QAA1BJ,QAA0B,CAAdI,QAAc;;AACvE,MAAMC,UAAU,gCAAW,oBAAX,EAAgC;AAC9CF,mBAD8C;AAE9CC;AAF8C,GAAhC,CAAhB;AAIA,MAAIC,QAAQC,MAAR,GAAiB,CAArB,EAAwB;AACtB,WAAOD,QAAQ,CAAR,CAAP;AACD;;AAED,MAAIF,eAAJ,EAAqB;AAAA,QACWI,WADX,GAC6BJ,eAD7B,CACXH,QADW,CACCI,QADD;;AAEnB,QAAIG,gBAAgBH,QAApB,EAA8B;AAC5B,aAAO,KAAP;AACD;AACF;AACD,SAAO,IAAP;AACD;;AAED,IAAMI,UAAU,gBAAMC,IAAN,CAAW;AAAA,SAAKC,EAAEC,IAAF,KAAY,gBAAjB;AAAA,CAAX,CAAhB;;AAEA,IAAMC,mBAAmB,SAAnBA,gBAAmB,GAAM;AAC7B,MAAIJ,OAAJ,EAAa;AACX,WAAO,iDAAqB;AAC1BK,WAAM,UADoB;AAE1BC,iBAAW;AAAA,eACT,0BAAc,uBAAaC,UAAb,CAAwBP,QAAQQ,kBAAhC,CAAd,6BACKC,KADL,EAEK,uBAAaC,IAAb,CAAkBV,QAAQW,QAA1B,CAFL,EADS;AAAA;AAFe,KAArB,CAAP;AAQD,GATD,MASO;AACL,WAAO,IAAP;AACD;AACF,CAbD;;AAeA,IAAMC,aAAa,SAAbA,UAAa,WAAY;AAC7B1B,SAAOI,UAAP,CAAkBuB,IAAlB,CAAuBjB,QAAvB;AACD,CAFD;;AAIAV,OAAO4B,aAAP,GAAuBF,UAAvB;;AAEA,IAAMG,YAAY,gCAAW,wBAAX,EAAoC,EAAE3B,OAAF,EAApC,EAAiD,CAAjD,CAAlB;AACA,IAAM4B,gBAAgB,SAAhBA,aAAgB;AAAA,MAAGC,QAAH,SAAGA,QAAH;AAAA,SACpB;AAAA;AAAA,MAAQ,SAAS7B,OAAjB;AAA2B6B;AAA3B,GADoB;AAAA,CAAtB;;AAGA;AACA,IAAIC,eAAJ;AACA,IAAI,uBAAaC,OAAb,CAAsB,OAAtB,CAAJ,EAAmC;AACjCD,WAAS,uBAAaC,OAAb,CAAsB,OAAtB,CAAT;AACD,CAFD,MAEO;AACLD,WAAS;AAAA,QAAGD,QAAH,SAAGA,QAAH;AAAA,WAAkB;AAAA;AAAA;AAAMA;AAAN,KAAlB;AAAA,GAAT;AACD;;AAED;AACA;AACA;AACA;;AAEA,IAAMG,OAAO,SAAPA,IAAO;AAAA,SACX,0BACEL,YAAYA,SAAZ,GAAwBC,aAD1B,EAEE,IAFF,EAGE,4DAEE,EAAEtB,kBAAF,EAFF,EAGE,0BAAc,gCAAWwB,MAAX,CAAd,EAAkC;AAChCD,cAAU;AAAA,aACR,iDAAqB;AACnBI,gBAAQ,4BAAc;AACpBhC,0BAAgBiC,WAAWlC,OAA3B;;AAEA,cAAMqB,QAAQc,cAAcA,WAAd,GAA4BD,UAA1C;AACA,cAAME,gBAAgB,iBAAOC,uBAAP,CACpBhB,MAAMjB,QAAN,CAAeI,QADK,CAAtB;AAGA,cAAI4B,aAAJ,EAAmB;AACjB,mBAAO,kFACFf,KADE;AAELe;AAFK,eAAP;AAID,WALD,MAKO;AACL,mBAAOpB,kBAAP;AACD;AACF;AAhBkB,OAArB,CADQ;AAAA;AADsB,GAAlC,CAHF;;AA2BJ;AA9BE,GADW;AAAA,CAAb,CAgCA,IAAMsB,cAAc,gCAAW,mBAAX,EAA+B,EAAEN,IAAF,EAA/B,EAAyCA,IAAzC,EAA+C,CAA/C,CAApB;;kBAEeM,W","file":"root.js","sourcesContent":["import React, { createElement } from \"react\"\nimport {\n  BrowserRouter as Router,\n  Route,\n  matchPath,\n  withRouter,\n} from \"react-router-dom\"\nimport { ScrollContext } from \"react-router-scroll\"\nimport createHistory from \"history/createBrowserHistory\"\n\nimport apiRunner from \"./api-runner-browser\"\nimport syncRequires from \"./sync-requires\"\nimport pages from \"./pages.json\"\nimport ComponentRenderer from \"./component-renderer\"\nimport loader from \"./loader\"\nloader.addPagesArray(pages)\nloader.addDevRequires(syncRequires)\nwindow.___loader = loader\n\nconst history = createHistory()\n\nfunction attachToHistory(history) {\n  window.___history = history\n\n  history.listen((location, action) => {\n    apiRunner(`onRouteUpdate`, { location, action })\n  })\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location: { pathname } }) {\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    pathname,\n  })\n  if (results.length > 0) {\n    return results[0]\n  }\n\n  if (prevRouterProps) {\n    const { location: { pathname: oldPathname } } = prevRouterProps\n    if (oldPathname === pathname) {\n      return false\n    }\n  }\n  return true\n}\n\nconst noMatch = pages.find(r => r.path === `/dev-404-page/`)\n\nconst addNotFoundRoute = () => {\n  if (noMatch) {\n    return createElement(Route, {\n      key: `404-page`,\n      component: props =>\n        createElement(syncRequires.components[noMatch.componentChunkName], {\n          ...props,\n          ...syncRequires.json[noMatch.jsonName],\n        }),\n    })\n  } else {\n    return null\n  }\n}\n\nconst navigateTo = pathname => {\n  window.___history.push(pathname)\n}\n\nwindow.___navigateTo = navigateTo\n\nconst AltRouter = apiRunner(`replaceRouterComponent`, { history })[0]\nconst DefaultRouter = ({ children }) =>\n  <Router history={history}>{children}</Router>\n\n// Use default layout if one isn't set.\nlet layout\nif (syncRequires.layouts[`index`]) {\n  layout = syncRequires.layouts[`index`]\n} else {\n  layout = ({ children }) => <div>{children()}</div>\n}\n\n// Always have to have one top-level layout\n// can have ones below that. Find page, if has different\n// parent layout(s), loop through those until finally the\n// page. Tricky part is avoiding re-mounting I think...\n\nconst Root = () =>\n  createElement(\n    AltRouter ? AltRouter : DefaultRouter,\n    null,\n    createElement(\n      ScrollContext,\n      { shouldUpdateScroll },\n      createElement(withRouter(layout), {\n        children: layoutProps =>\n          createElement(Route, {\n            render: routeProps => {\n              attachToHistory(routeProps.history)\n\n              const props = layoutProps ? layoutProps : routeProps\n              const pageResources = loader.getResourcesForPathname(\n                props.location.pathname\n              )\n              if (pageResources) {\n                return createElement(ComponentRenderer, {\n                  ...props,\n                  pageResources,\n                })\n              } else {\n                return addNotFoundRoute()\n              }\n            },\n          }),\n      })\n    )\n  )\n\n// Let site, plugins wrap the site e.g. for Redux.\nconst WrappedRoot = apiRunner(`wrapRootComponent`, { Root }, Root)[0]\n\nexport default WrappedRoot\n"]}