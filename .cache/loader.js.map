{"version":3,"sources":["../../src/cache-dir/loader.js"],"names":["findPage","syncRequires","asyncRequires","pathScriptsCache","resourceStrCache","resourceCache","pages","pathArray","pathCount","resourcesArray","resourcesCount","preferDefault","m","default","prefetcher","process","env","NODE_ENV","require","getNextQueuedResources","slice","createResourceDownload","fetchResource","resourceName","filter","r","onResourcedFinished","on","onPreLoadPageResources","e","onPostLoadPageResources","sortResourcesByCount","a","b","sortPagesByCount","cb","nextTick","resourceFunction","components","json","err","executeChunk","getResourceModule","module","mountOrder","queue","empty","addPagesArray","newPages","pathPrefix","__PREFIX_PATHS__","__PATH_PREFIX__","addDevRequires","devRequires","addProdRequires","prodRequires","dequeue","pop","enqueue","some","p","path","mountOrderBoost","has","unshift","sort","page","jsonName","indexOf","componentChunkName","onNewResourcesAdded","getResources","getPages","getPage","pathname","getResourcesForPathname","pageResources","component","console","log","emit","done","c","j","undefined","peek","length","exports"],"mappings":"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","file":"loader.js","sourcesContent":["import pageFinderFactory from \"./find-page\"\nimport emitter from \"./emitter\"\nlet findPage\n\nlet syncRequires = {}\nlet asyncRequires = {}\nlet pathScriptsCache = {}\nlet resourceStrCache = {}\nlet resourceCache = {}\nlet pages = []\n// Note we're not actively using the path data atm. There\n// could be future optimizations however around trying to ensure\n// we load all resources for likely-to-be-visited paths.\nlet pathArray = []\nlet pathCount = {}\nlet resourcesArray = []\nlet resourcesCount = {}\nconst preferDefault = m => (m && m.default) || m\nlet prefetcher\n\n// Prefetcher logic\nif (process.env.NODE_ENV === `production`) {\n  prefetcher = require(`./prefetcher`)({\n    getNextQueuedResources: () => resourcesArray.slice(-1)[0],\n    createResourceDownload: resourceName => {\n      fetchResource(resourceName, () => {\n        resourcesArray = resourcesArray.filter(r => r !== resourceName)\n        prefetcher.onResourcedFinished(resourceName)\n      })\n    },\n  })\n  emitter.on(`onPreLoadPageResources`, e => {\n    prefetcher.onPreLoadPageResources(e)\n  })\n  emitter.on(`onPostLoadPageResources`, e => {\n    prefetcher.onPostLoadPageResources(e)\n  })\n}\n\nconst sortResourcesByCount = (a, b) => {\n  if (resourcesCount[a] > resourcesCount[b]) {\n    return 1\n  } else if (resourcesCount[a] < resourcesCount[b]) {\n    return -1\n  } else {\n    return 0\n  }\n}\n\nconst sortPagesByCount = (a, b) => {\n  if (pathCount[a] > pathCount[b]) {\n    return 1\n  } else if (pathCount[a] < pathCount[b]) {\n    return -1\n  } else {\n    return 0\n  }\n}\n\nconst fetchResource = (resourceName, cb = () => {}) => {\n  if (resourceStrCache[resourceName]) {\n    process.nextTick(() => {\n      cb(null, resourceStrCache[resourceName])\n    })\n  } else {\n    // Find resource\n    const resourceFunction = resourceName.slice(0, 6) === `page-c`\n      ? asyncRequires.components[resourceName]\n      : asyncRequires.json[resourceName]\n\n    // Download the resource\n    resourceFunction((err, executeChunk) => {\n      resourceStrCache[resourceName] = executeChunk\n      cb(err, executeChunk)\n    })\n  }\n}\n\nconst getResourceModule = (resourceName, cb) => {\n  if (resourceCache[resourceName]) {\n    process.nextTick(() => {\n      cb(null, resourceCache[resourceName])\n    })\n  } else {\n    fetchResource(resourceName, (err, executeChunk) => {\n      if (err) {\n        cb(err)\n      } else {\n        const module = preferDefault(executeChunk())\n        resourceCache[resourceName] = module\n        cb(err, module)\n      }\n    })\n  }\n}\n\nlet mountOrder = 1\nconst queue = {\n  empty: () => {\n    pathArray = []\n    pathCount = {}\n    resourcesCount = {}\n    resourcesArray = []\n    pages = []\n  },\n  addPagesArray: newPages => {\n    pages = newPages\n    let pathPrefix = ``\n    if (typeof __PREFIX_PATHS__ !== `undefined`) {\n      pathPrefix = __PATH_PREFIX__\n    }\n    findPage = pageFinderFactory(newPages, pathPrefix)\n  },\n  addDevRequires: devRequires => {\n    syncRequires = devRequires\n  },\n  addProdRequires: prodRequires => {\n    asyncRequires = prodRequires\n  },\n  dequeue: path => pathArray.pop(),\n  enqueue: path => {\n    // Check page exists.\n    if (!pages.some(p => p.path === path)) {\n      return false\n    }\n\n    const mountOrderBoost = 1 / mountOrder\n    mountOrder += 1\n    // console.log(\n    // `enqueue \"${path}\", mountOrder: \"${mountOrder}, mountOrderBoost: ${mountOrderBoost}`\n    // )\n\n    // Add to path counts.\n    if (!pathCount[path]) {\n      pathCount[path] = 1\n    } else {\n      pathCount[path] += 1\n    }\n\n    // Add path to queue.\n    if (!queue.has(path)) {\n      pathArray.unshift(path)\n    }\n\n    // Sort pages by pathCount\n    pathArray.sort(sortPagesByCount)\n\n    // Add resources to queue.\n    const page = findPage(path)\n    if (page.jsonName) {\n      if (!resourcesCount[page.jsonName]) {\n        resourcesCount[page.jsonName] = 1 + mountOrderBoost\n      } else {\n        resourcesCount[page.jsonName] += 1 + mountOrderBoost\n      }\n\n      // Before adding, checking that the JSON resource isn't either\n      // already queued or been downloading.\n      if (\n        resourcesArray.indexOf(page.jsonName) === -1 &&\n        !resourceStrCache[page.jsonName]\n      ) {\n        resourcesArray.unshift(page.jsonName)\n      }\n    }\n    if (page.componentChunkName) {\n      if (!resourcesCount[page.componentChunkName]) {\n        resourcesCount[page.componentChunkName] = 1 + mountOrderBoost\n      } else {\n        resourcesCount[page.componentChunkName] += 1 + mountOrderBoost\n      }\n\n      // Before adding, checking that the component resource isn't either\n      // already queued or been downloading.\n      if (\n        resourcesArray.indexOf(page.componentChunkName) === -1 &&\n        !resourceStrCache[page.jsonName]\n      ) {\n        resourcesArray.unshift(page.componentChunkName)\n      }\n    }\n\n    // Sort resources by resourcesCount.\n    resourcesArray.sort(sortResourcesByCount)\n    if (process.env.NODE_ENV === `production`) {\n      prefetcher.onNewResourcesAdded()\n    }\n\n    return true\n  },\n  getResources: () => {\n    return {\n      resourcesArray,\n      resourcesCount,\n    }\n  },\n  getPages: () => {\n    return {\n      pathArray,\n      pathCount,\n    }\n  },\n  getPage: pathname => findPage(pathname),\n  has: path => pathArray.some(p => p === path),\n  getResourcesForPathname: (path, cb = () => {}) => {\n    // In development we know the code is loaded already\n    // so we just return with it immediately.\n    if (process.env.NODE_ENV !== `production`) {\n      const page = findPage(path)\n      if (!page) return\n\n      const pageResources = {\n        component: syncRequires.components[page.componentChunkName],\n        json: syncRequires.json[page.jsonName],\n      }\n      cb(pageResources)\n      return pageResources\n      // Production code path\n    } else {\n      const page = findPage(path)\n\n      if (!page) {\n        console.log(`A page wasn't found for \"${path}\"`)\n        return\n      }\n\n      // Use the path from the page so the pathScriptsCache uses\n      // the normalized path.\n      path = page.path\n\n      // Check if it's in the cache already.\n      if (pathScriptsCache[path]) {\n        process.nextTick(() => {\n          cb(pathScriptsCache[path])\n          emitter.emit(`onPostLoadPageResources`, {\n            page,\n            pageResources: pathScriptsCache[path],\n          })\n        })\n        return pathScriptsCache[path]\n      }\n\n      emitter.emit(`onPreLoadPageResources`, { path })\n      // Nope, we need to load resource(s)\n      let component\n      let json\n      // Load the component/json and parallal and call this\n      // function when they're done loading. When both are loaded,\n      // we move on.\n      const done = () => {\n        if (component && json) {\n          pathScriptsCache[path] = { component, json }\n          const pageResources = { component, json }\n          cb(pageResources)\n          emitter.emit(`onPostLoadPageResources`, {\n            page,\n            pageResources,\n          })\n        }\n      }\n      getResourceModule(page.componentChunkName, (err, c) => {\n        if (err) {\n          console.log(`Loading the component for ${page.path} failed`)\n        }\n        component = c\n        done()\n      })\n      getResourceModule(page.jsonName, (err, j) => {\n        if (err) {\n          console.log(`Loading the JSON for ${page.path} failed`)\n        }\n        json = j\n        done()\n      })\n\n      return undefined\n    }\n  },\n  peek: path => pathArray.slice(-1)[0],\n  length: () => pathArray.length,\n  indexOf: path => pathArray.length - pathArray.indexOf(path) - 1,\n}\n\nmodule.exports = queue\n"]}